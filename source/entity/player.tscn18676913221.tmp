[gd_scene load_steps=20 format=3 uid="uid://dfw7tpcupxmeq"]

[ext_resource type="Texture2D" uid="uid://dd28gk2sytn4y" path="res://assets/textures/main_characters/Mask Dude/Idle (32x32).png" id="1_1dj28"]
[ext_resource type="Script" uid="uid://dn20is148oh5k" path="res://source/entity/player.gd" id="1_5bw4n"]
[ext_resource type="AnimationLibrary" uid="uid://d2xtwkoev3qif" path="res://assets/animations/animation_mask_dude.tres" id="3_4xhno"]

[sub_resource type="CapsuleShape2D" id="CapsuleShape2D_5bw4n"]

[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_4xhno"]
animation = &"idle"

[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_trqsh"]
animation = &"jump"

[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_8y6tv"]
animation = &"fall"

[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_022ct"]
animation = &"run"

[sub_resource type="AnimationNodeBlendSpace1D" id="AnimationNodeBlendSpace1D_4xhno"]
blend_point_0/node = SubResource("AnimationNodeAnimation_trqsh")
blend_point_0/pos = -1.0
blend_point_1/node = SubResource("AnimationNodeAnimation_8y6tv")
blend_point_1/pos = 1.0
blend_point_2/node = SubResource("AnimationNodeAnimation_022ct")
blend_point_2/pos = 0.0
value_label = "velocity.y"
blend_mode = 1

[sub_resource type="AnimationNodeStateMachineTransition" id="AnimationNodeStateMachineTransition_4xhno"]

[sub_resource type="AnimationNodeStateMachineTransition" id="AnimationNodeStateMachineTransition_tvgm1"]

[sub_resource type="AnimationNodeStateMachineTransition" id="AnimationNodeStateMachineTransition_trqsh"]
advance_mode = 2

[sub_resource type="AnimationNodeStateMachine" id="AnimationNodeStateMachine_4xhno"]
states/Idle/node = SubResource("AnimationNodeAnimation_4xhno")
states/Idle/position = Vector2(313, 83)
states/Move/node = SubResource("AnimationNodeBlendSpace1D_4xhno")
states/Move/position = Vector2(445, 83)
states/Start/position = Vector2(198, 83)
transitions = ["Idle", "Move", SubResource("AnimationNodeStateMachineTransition_4xhno"), "Move", "Idle", SubResource("AnimationNodeStateMachineTransition_tvgm1"), "Start", "Idle", SubResource("AnimationNodeStateMachineTransition_trqsh")]

[sub_resource type="GDScript" id="GDScript_4xhno"]
script/source = "@icon(\"state_chart.svg\")
@tool
## This is statechart. It contains a root state (commonly a compound or parallel state) and is the entry point for 
## the state machine.
class_name StateChart 
extends Node

## The the remote debugger
const DebuggerRemote = preload(\"utilities/editor_debugger/editor_debugger_remote.gd\")

## The state chart utility class.
const StateChartUtil = preload(\"utilities/state_chart_util.gd\")

## Emitted when the state chart receives an event. This will be 
## emitted no matter which state is currently active and can be 
## useful to trigger additional logic elsewhere in the game 
## without having to create a custom event bus. It is also used
## by the state chart debugger. Note that this will emit the 
## events in the order in which they are processed, which may 
## be different from the order in which they were received. This is
## because the state chart will always finish processing one event
## fully before processing the next. If an event is received
## while another is still processing, it will be enqueued.
signal event_received(event:StringName)

@export_group(\"Debugging\")
## Flag indicating if this state chart should be tracked by the 
## state chart debugger in the editor.
@export var track_in_editor:bool = false

## If set, the state chart will issue a warning when trying to
## send an event that is not configured for any transition of 
## the state chart. It is usually a good idea to leave this
## enabled, but in certain cases this may get in the way so
## you can disable it here.
@export var warn_on_sending_unknown_events:bool = true

@export_group(\"\")
## Initial values for the expression properties. These properties can be used in expressions, e.g
## for guards or transition delays. It is recommended to set an initial value for each property
## you use in an expression to ensure that this expression is always valid. If you don't set
## an initial value, some expressions may fail to be evaluated if they use a property that has
## not been set yet.
@export var initial_expression_properties:Dictionary = {}

## The root state of the state chart.
var _state:StateChartState = null

## This dictonary contains known properties used in expression guards. Use the 
## [method set_expression_property] to add properties to this dictionary.
var _expression_properties:Dictionary = {
}

## A list of pending events 
var _queued_events:Array[StringName] = []

## Whether or not a property change is pending.
var _property_change_pending:bool = false

## Whether or not a state change occured during processing and we need to re-run 
## automatic transitions that may have been triggered by the state change.
var _state_change_pending:bool = false

## Flag indicating if the state chart is currently processing. 
## Until a change is fully processed, no further changes can
## be introduced from the outside.
var _locked_down:bool = false

## Flag indicating if the state chart is frozen.
## If the state chart is frozen, new events and transitions will be discarded.
var _frozen:bool = false

var _queued_transitions:Array[Dictionary] = []
var _transitions_processing_active:bool = false

var _debugger_remote:DebuggerRemote = null
var _valid_event_names:Array[StringName] = []

## A trigger type that defines events that can trigger a transition.
enum TriggerType {
	## No trigger type. This usually should not happen and is used as a default value.
	NONE = 0,
	## The transition will be triggered by an event.
	EVENT = 1,
	## The transition is automatic and thus will be triggered when the state is entered.
	STATE_ENTER = 2,
	## The transition is automatic and will be triggered by a property change.
	PROPERTY_CHANGE = 4,
	## The transition is automatic and will be triggered by a state change.
	STATE_CHANGE = 8,
}

func _ready() -> void:
	if Engine.is_editor_hint():
		return 

	# check if we have exactly one child that is a state
	if get_child_count() != 1:
		push_error(\"StateChart must have exactly one child\")
		return

	# check if the child is a state
	var child:Node = get_child(0)
	if not child is StateChartState:
		push_error(\"StateMachine's child must be a State\")
		return
		
	# in debug builds, collect a list of valid event names
	# to warn the developer when using an event that doesn't
	# exist.
	if OS.is_debug_build():
		_valid_event_names = StateChartUtil.events_of(self)
	
	# set the initial expression properties
	if initial_expression_properties != null:
		for key in initial_expression_properties.keys():
			if not key is String and not key is StringName:
				push_error(\"Expression property names must be strings. Ignoring initial expression property with key \", key)
				continue
			_expression_properties[key] = initial_expression_properties[key]

	# initialize the state machine
	_state = child as StateChartState
	_state._state_init()

	# We wait one frame before entering initial state, so
	# parents of the state chart have a chance to run their
	# _ready methods first and not get events from the state
	# chart while they have not yet been initialized
	_enter_initial_state.call_deferred()

	# if we are in an editor build and this chart should be tracked 
	# by the debugger, create a debugger remote
	if track_in_editor and OS.has_feature(\"editor\") and not Engine.is_editor_hint():
		_debugger_remote = DebuggerRemote.new(self)
		# add the remote as a child, so it gets cleaned up when the state
		# chart is deleted
		add_child(_debugger_remote)


func _enter_initial_state():
	# https://github.com/derkork/godot-statecharts/issues/143
	# make sure that transitions resulting from state_enter handlers still 
	# adhere our transactional processing
	_transitions_processing_active = true
	_locked_down = true

	# enter the state
	_state._state_enter(null)
	
	# run any queued transitions that may have come up during the enter
	_run_queued_transitions()
	
	# run any queued external events that may have come up during the enter
	_run_changes()


## Sends an event to this state chart. The event will be passed to the innermost active state first and
## is then moving up in the tree until it is consumed. Events will trigger transitions and actions via emitted
## signals. There is no guarantee when the event will be processed. The state chart
## will process the event as soon as possible but there is no guarantee that the 
## event will be fully processed when this method returns.
func send_event(event:StringName) -> void:
	if _frozen:
		push_error(\"The state chart is currently frozen. Cannot set send events.\")

		return

	if not is_node_ready():
		push_error(\"State chart is not yet ready. If you call `send_event` in _ready, please call it deferred, e.g. `state_chart.send_event.call_deferred(\\\"my_event\\\").\")
		return
		
	if not is_instance_valid(_state):
		push_error(\"State chart has no root state. Ignoring call to `send_event`.\")
		return
		
	if warn_on_sending_unknown_events and event != \"\" and OS.is_debug_build() and not _valid_event_names.has(event):
		push_warning(\"State chart does not have an event '\", event , \"' defined. Sending this event will do nothing.\")
	
	_queued_events.append(event)
	if _locked_down:
		return
		
	_run_changes()
		
		
## Sets a property that can be used in expression guards. The property will be available as a global variable
## with the same name. E.g. if you set the property \"foo\" to 42, you can use the expression \"foo == 42\" in
## an expression guard.
func set_expression_property(name:StringName, value) -> void:
	if _frozen:
		push_error(\"The state chart is currently frozen. Cannot set expression properties.\")
		return

	if not is_node_ready():
		push_error(\"State chart is not yet ready. If you call `set_expression_property` in `_ready`, please call it deferred, e.g. `state_chart.set_expression_property.call_deferred(\\\"my_property\\\", 5).\")
		return
		
	if not is_instance_valid(_state):
		push_error(\"State chart has no root state. Ignoring call to `set_expression_property`.\")
		return
	
	_expression_properties[name] = value
	_property_change_pending = true
	
	if not _locked_down:
		_run_changes()
		

## Returns the value of a previously set expression property. If the property does not exist, the default value
## will be returned.
func get_expression_property(name:StringName, default:Variant = null) -> Variant:
	return _expression_properties.get(name, default)


func _run_changes() -> void:
	# enable the reentrance lock
	_locked_down = true
	
	while (not _queued_events.is_empty()) or _property_change_pending or _state_change_pending:
		# We process stuff in this order:
		# 1. State changes
		if _state_change_pending:		
			_state_change_pending = false
			_state._process_transitions(TriggerType.STATE_CHANGE)

		# 2. Property changes
		if _property_change_pending:
			_property_change_pending = false
			_state._process_transitions(TriggerType.PROPERTY_CHANGE)

		# 3. Events
		if not _queued_events.is_empty():
			# process the next event	
			var next_event = _queued_events.pop_front()
			event_received.emit(next_event)
			_state._process_transitions(TriggerType.EVENT, next_event)
	
	_locked_down = false


## Allows states to queue a transition for running. This will eventually run the transition
## once all currently running transitions have finished. States should call this method
## when they want to transition away from themselves. 
func _run_transition(transition:Transition, source:StateChartState) -> void:
	# Queue up the transition for running
	_queued_transitions.append({transition : source})
	
	# if we are currently inside of a transition, finish processing the queue so we 
	# get a predictable order. Queing can happen a state has an automatic transition on enter, 
	# or when a transition is triggered as part of a signal handler. In these cases, we want to
	# finish the current transition before starting a new one because otherwise the transitions
	# see really unpredictable state changes. In a sense, every transition is also a
	# transaction that needs to be fully processed before the next one can start.
	if _transitions_processing_active:
		return
		
	_run_queued_transitions()
	

## Runs all queued transitions until none are left. This also checks for infinite loops in transitions and 
## ensures triggering guards on state changes.
func _run_queued_transitions() -> void:

	_transitions_processing_active = true

	var execution_count := 1
	
	# if we still have transitions
	while _queued_transitions.size() > 0:
		var next_transition_entry = _queued_transitions.pop_front()
		var next_transition = next_transition_entry.keys()[0]
		var next_transition_source = next_transition_entry[next_transition]
		_do_run_transition(next_transition, next_transition_source)
		execution_count += 1
	
		if execution_count > 100:
			push_error(\"Infinite loop detected in transitions. Aborting. The state chart is now in an invalid state and no longer usable.\")
			break
	
	_transitions_processing_active = false
	
	# transitions trigger a state change which can in turn activate
	# other transitions, so we need to handle these
	if not _locked_down:
		_run_changes()


## Runs the transition. Used internally by the state chart, do not call this directly.	
func _do_run_transition(transition:Transition, source:StateChartState):
	if source.active:
		# Notify interested parties that the transition is about to be taken
		transition.taken.emit()
		source._handle_transition(transition, source)
		_state_change_pending = true
	else:
		_warn_not_active(transition, source)	


func _warn_not_active(transition:Transition, source:StateChartState):
	push_warning(\"Ignoring request for transitioning from \", source.name, \" to \", transition.to, \" as the source state is no longer active. Check whether your trigger multiple state changes within a single frame.\")



## Calls the `step` function in all active states. Used for situations where `state_processing` and 
## `state_physics_processing` don't make sense (e.g. turn-based games, or games with a fixed timestep).
func step() -> void:
	if _frozen:
		push_error(\"The state chart is currently frozen. Cannot step.\")
		return

	if not is_node_ready():
		push_error(\"State chart is not yet ready. If you call `step` in `_ready`, please call it deferred, e.g. `state_chart.step.call_deferred()`.\")
		return
		
	if not is_instance_valid(_state):
		push_error(\"State chart has no root state. Ignoring call to `step`.\")
		return
	_state._state_step()


func _get_configuration_warnings() -> PackedStringArray:
	var warnings:PackedStringArray = []
	if get_child_count() != 1:
		warnings.append(\"StateChart must have exactly one child\")
	else:
		var child:Node = get_child(0)
		if not child is StateChartState:
			warnings.append(\"StateChart's child must be a State\")
	return warnings


## Freezes the state chart and all states. While frozen, no changes can be made to a state chart.
func freeze():
	_frozen = true
	var to_freeze:Array[StateChartState] = [_state]
	while not to_freeze.is_empty():
		var next := to_freeze.pop_back()
		next._toggle_processing(true)
		for child in next.get_children():
			if child is StateChartState:
				to_freeze.append(child)

## Thaws the state chart and all states. After being thawed, changes can again be made to the state chart.
func thaw():
	var to_thaw:Array[StateChartState] = [_state]
	while not to_thaw.is_empty():
		var next := to_thaw.pop_back()
		next._toggle_processing(false)
		for child in next.get_children():
			if child is StateChartState:
				to_thaw.append(child)

	_frozen = false
"

[sub_resource type="GDScript" id="GDScript_tvgm1"]
script/source = "@tool
@icon(\"parallel_state.svg\")
## A parallel state is a state which can have sub-states, all of which are active
## when the parallel state is active.
class_name ParallelState
extends StateChartState

# all children of the state
var _sub_states:Array[StateChartState] = []

func _state_init():
	super._state_init()
	# find all children of this state which are states
	for child in get_children():
		if child is StateChartState:
			_sub_states.append(child)
			child._state_init()

	# since there is no state transitions between parallel states, we don't need to
	# subscribe to events from our children


func _handle_transition(transition:Transition, source:StateChartState):
	# resolve the target state
	var target = transition.resolve_target()
	if not target is StateChartState:
		push_error(\"The target state '\" + str(transition.to) + \"' of the transition from '\" + source.name + \"' is not a state.\")
		return
	
	# the target state can be
	# 0. this state. in this case just activate the state and all its children.
	#    this can happen when a child state transfers back to its parent state.
	# 1. a direct child of this state. this is the easy case in which
	#    we will do nothing, because our direct children are always active.
	# 2. a descendant of this state. in this case we find the direct child which
	#    is the ancestor of the target state and then ask it to perform
	#    the transition.
	# 3. no descendant of this state. in this case, we ask our parent state to
	#    perform the transition

	if target == self:
		# exit this state
		_state_exit()
		# then re-enter it
		_state_enter(target)
		return

	if target in get_children():
		# all good, nothing to do.
		return
		
	if self.is_ancestor_of(target):
		# find the child which is the ancestor of the new target.
		for child in get_children():
			if child is StateChartState and child.is_ancestor_of(target):
				# ask child to handle the transition
				child._handle_transition(transition, source)
				return
		return
	
	# ask the parent
	get_parent()._handle_transition(transition, source)

func _state_enter(transition_target:StateChartState):
	super._state_enter(transition_target)
	# enter all children
	for child in _sub_states:
		child._state_enter(transition_target)
	
func _state_exit():
	# exit all children
	for child in _sub_states:
		child._state_exit()
	
	super._state_exit()

func _state_step():
	super._state_step()
	for child in _sub_states:
		child._state_step()

func _process_transitions(trigger_type:StateChart.TriggerType, event:StringName = \"\") -> bool:
	if not active:
		return false

	# forward to all children
	var handled := false
	for child in _sub_states:
		var child_handled_it = child._process_transitions(trigger_type, event)
		handled = handled or child_handled_it

	# if any child handled this, we don't touch it anymore
	if handled:
		# emit the event_received signal for completeness
		# if the trigger type is event
		if trigger_type == StateChart.TriggerType.EVENT:
			self.event_received.emit(event)
		return true

	# otherwise handle it ourselves
	# defer to the base class
	return super._process_transitions(trigger_type, event)

func _get_configuration_warnings() -> PackedStringArray:
	var warnings = super._get_configuration_warnings()
	
	var child_count = 0
	for child in get_children():
		if child is StateChartState:
			child_count += 1
	
	if child_count < 2:
		warnings.append(\"Parallel states should have at least two child states.\")
	
	
	return warnings
"

[sub_resource type="GDScript" id="GDScript_trqsh"]
script/source = "@tool
@icon(\"compound_state.svg\")
## A compound state is a state that has multiple sub-states of which exactly one can
## be active at any given time.
class_name CompoundState
extends StateChartState

## Called when a child state is entered.
signal child_state_entered()

## Called when a child state is exited.
signal child_state_exited()

## The initial state which should be activated when this state is activated.
@export_node_path(\"StateChartState\") var initial_state:NodePath:
	get:
		return initial_state
	set(value):
		initial_state = value
		update_configuration_warnings() 


## The currently active substate.
var _active_state:StateChartState = null

## The initial state
@onready var _initial_state:StateChartState = get_node_or_null(initial_state)

## The history states of this compound state.
var _history_states:Array[HistoryState] = []
## Whether any of the history states needs a deep history.
var _needs_deep_history:bool = false

func _init() -> void:
	# subscribe to the child_entered_tree signal in edit mode so we can
	# automatically set the initial state when a new sub-state is added
	if Engine.is_editor_hint():
		child_entered_tree.connect(
			func(child:Node):
			# when a child is added in the editor and the child is a state
			# and we don't have an initial state yet, set the initial state 
			# to the newly added child
			if child is StateChartState and initial_state.is_empty():
				# the newly added node may have a random name now, 
				# so we need to defer the call to build a node path
				# to the next frame, so the editor has time to rename
				# the node to its final name
				(func(): initial_state = get_path_to(child)).call_deferred()
		)

	
func _state_init():
	super._state_init()

	# check if we have any history states
	for child in get_children():
		if child is HistoryState:
			var child_as_history_state:HistoryState = child as HistoryState
			_history_states.append(child_as_history_state)
			# remember if any of the history states needs a deep history
			_needs_deep_history = _needs_deep_history or child_as_history_state.deep

	# initialize all substates. find all children of type State and call _state_init on them.
	for child in get_children():
		if child is StateChartState:
			var child_as_state:StateChartState = child as StateChartState
			child_as_state._state_init()
			child_as_state.state_entered.connect(func(): child_state_entered.emit())
			child_as_state.state_exited.connect(func(): child_state_exited.emit())

func _state_enter(transition_target:StateChartState):
	super._state_enter(transition_target)

	# activate the initial state _unless_ one of these are true 
	# - the transition target is a descendant of this state
	# - we already have an active state because entering the state triggered an immediate transition to a child state
	# - we are no longer active becasue entering the state triggered an immediate transition to some other state
	var target_is_descendant := false
	if transition_target != null and is_ancestor_of(transition_target):
		target_is_descendant = true
	
	if not target_is_descendant and not is_instance_valid(_active_state) and _state_active:
		if _initial_state != null:
			if _initial_state is HistoryState:
				_restore_history_state(_initial_state)
			else:
				_active_state = _initial_state
				_active_state._state_enter(null)
		else:
			push_error(\"No initial state set for state '\" + name + \"'.\")

func _state_step():
	super._state_step()
	if _active_state != null:
		_active_state._state_step()

func _state_save(saved_state:SavedState, child_levels:int = -1):
	super._state_save(saved_state, child_levels)

	# in addition save all history states, as they are never active and normally would not be saved
	var parent = saved_state.get_substate_or_null(self)
	if parent == null:
		push_error(\"Probably a bug: The state of '\" + name + \"' was not saved.\")
		return

	for history_state in _history_states:
		history_state._state_save(parent, child_levels)

func _state_restore(saved_state:SavedState, child_levels:int = -1):
	super._state_restore(saved_state, child_levels)

	# in addition check if we are now active and if so determine the current active state
	if active:
		# find the currently active child
		for child in get_children():
			if child is StateChartState and child.active:
				_active_state = child
				break

func _state_exit():
	# if we have any history states, we need to save the current active state
	if _history_states.size() > 0:
		var saved_state = SavedState.new()
		# we save the entire hierarchy if any of the history states needs a deep history
		# otherwise we only save this level. This way we can save memory and processing time
		_state_save(saved_state, -1 if _needs_deep_history else 1)

		# now save the saved state in all history states
		for history_state in _history_states:
			# when saving history it's ok when we save deep history in a history state that doesn't need it
			# because at restore time we will use the state's deep flag to determine if we need to restore
			# the entire hierarchy or just this level. This way we don't need multiple copies of the same
			# state hierarchy.
			history_state.history = saved_state

	# deactivate the current state
	if _active_state != null:
		_active_state._state_exit()
		_active_state = null
	super._state_exit()


func _process_transitions(trigger_type:StateChart.TriggerType, event:StringName = \"\") -> bool:
	if not active:
		return false

	# forward to the active state
	if is_instance_valid(_active_state):
		if _active_state._process_transitions(trigger_type, event):
			# emit the event_received signal when the trigger type is event
			if trigger_type == StateChart.TriggerType.EVENT:
				self.event_received.emit(event)
			return true

	# if the event was not handled by the active state, we handle it here
	# base class will also emit the event_received signal
	return super._process_transitions(trigger_type, event)


func _handle_transition(transition:Transition, source:StateChartState):
	# print(\"CompoundState._handle_transition: \" + name + \" from \" + source.name + \" to \" + str(transition.to))
	# resolve the target state
	var target = transition.resolve_target()
	if not target is StateChartState:
		push_error(\"The target state '\" + str(transition.to) + \"' of the transition from '\" + source.name + \"' is not a state.\")
		return
	
	# the target state can be
	# 0. this state. in this case exit this state and re-enter it. This can happen when
	#    a child state transfers to its parent state.
	# 1. a direct child of this state. this is the easy case in which
	#    we will deactivate the current _active_state and activate the target
	# 2. a descendant of this state. in this case we find the direct child which
	#    is the ancestor of the target state, activate it and then ask it to perform
	#    the transition.
	# 3. no descendant of this state. in this case, we ask our parent state to
	#    perform the transition

	if target == self:
		# exit this state and re-enter it
		_state_exit()
		_state_enter(target)
		return

	if target in get_children():
		# all good, now first deactivate the current state
		if is_instance_valid(_active_state):
			_active_state._state_exit()
		
		# now check if the target is a history state, if this is the 
		# case, we need to restore the saved state
		if target is HistoryState:
			_restore_history_state(target)
			return

		# else, just activate the target state
		_active_state = target
		_active_state._state_enter(target)
		return
		
	if self.is_ancestor_of(target):
		# find the child which is the ancestor of the new target.
		for child in get_children():
			if child is StateChartState and child.is_ancestor_of(target):
				# found it. 
				# change active state if necessary
				if _active_state != child:
					if is_instance_valid(_active_state):
						_active_state._state_exit()

					_active_state = child
					# give the transition target because we will send
					# the transition to the child state right after we activate it.
					# this avoids the child needlessly entering the initial state
					_active_state._state_enter(target)
					
				# ask child to handle the transition
				child._handle_transition(transition, source)
				return
		return
	
	# ask the parent
	get_parent()._handle_transition(transition, source)


func _restore_history_state(target:HistoryState):
	# print(\"Target is history state, restoring saved state.\")
	var saved_state = target.history
	if saved_state != null:
		# restore the saved state
		_state_restore(saved_state, -1 if target.deep else 1)
		return
	# print(\"No history saved so far, activating default state.\")
	# if we don't have history, we just activate the default state
	var default_state = target.get_node_or_null(target.default_state)
	if is_instance_valid(default_state):
		_active_state = default_state
		_active_state._state_enter(null)
		return
	else:
		push_error(\"The default state '\" + str(target.default_state) + \"' of the history state '\" + target.name + \"' cannot be found.\")
		return


func _get_configuration_warnings() -> PackedStringArray:
	var warnings = super._get_configuration_warnings()
	
	# count the amount of child states
	var child_count = 0
	for child in get_children():
		if child is StateChartState:
			child_count += 1

	if child_count < 1:
		warnings.append(\"Compound states should have at least one child state.\")
	
	elif child_count < 2:
		warnings.append(\"Compound states with only one child state are not very useful. Consider adding more child states or removing this compound state.\")
		
	var the_initial_state = get_node_or_null(initial_state)
	
	if not is_instance_valid(the_initial_state):
		warnings.append(\"Initial state could not be resolved, is the path correct?\")
		
	elif the_initial_state.get_parent() != self:
		warnings.append(\"Initial state must be a direct child of this compound state.\")
	
	return warnings
"

[sub_resource type="GDScript" id="GDScript_8y6tv"]
script/source = "@tool
@icon(\"atomic_state.svg\")
## This is a state that has no sub-states.
class_name AtomicState
extends StateChartState

func _handle_transition(transition:Transition, source:StateChartState):
	# resolve the target state
	var target = transition.resolve_target()
	if not target is StateChartState:
		push_error(\"The target state '\" + str(transition.to) + \"' of the transition from '\" + source.name + \"' is not a state.\")
		return
	# atomic states cannot transition, so we need to ask the parent
	# ask the parent
	get_parent()._handle_transition(transition, source)


func _get_configuration_warnings() -> PackedStringArray :
	var warnings = super._get_configuration_warnings()
	# check if we have any child nodes which are not transitions
	for child in get_children():
		if child is StateChartState:
			warnings.append(\"Atomic states cannot have child states. These will be ignored.\")
			break
	return warnings
"

[sub_resource type="GDScript" id="GDScript_022ct"]
script/source = "@tool
@icon(\"transition.svg\")
class_name Transition
extends Node

const ExpressionUtil = preload(\"expression_util.gd\")
const DebugUtil = preload(\"debug_util.gd\")

## Flag indicating that this transition has been modified and needs to update its caches.
var _dirty:bool = true

## Cached target state of this transition. Will be resolved when [method resolve_target] is called.
var _target:StateChartState = null

## The trigger types that are supported by this transition. This is a bit mask of the supported trigger types.
## The trigger types are defined in the [StateChart] class.
var _supported_trigger_types:int = 0

## Fired when this transition is taken. For delayed transitions, this signal
## will be fired when the transition is actually executed (e.g. when its delay
## has elapsed and the transition has not been arborted before). The signal will
## always be fired before the state is exited.
signal taken()

## The target state to which the transition should switch
@export_node_path(\"StateChartState\") var to:NodePath:
	set(value):
		to = value
		_dirty = true
		update_configuration_warnings()

## The event that should trigger this transition, can be empty in which case
## the transition will immediately be tried when the state is entered
@export var event:StringName = \"\":
	set(value):
		event = value
		_dirty = true
		update_configuration_warnings()

## An expression that must evaluate to true for the transition to be taken. Can be
## empty in which case the transition will always be taken
@export var guard:Guard:
	set(value):
		guard = value
		_dirty = true
		update_configuration_warnings()

## A delay in seconds before the transition is taken. Can be 0 in which case
## the transition will be taken immediately. The transition will only be taken
## if the state is still active when the delay has passed and has never been left.
## @deprecated: use the new delay_in_seconds property instead
var delay_seconds:float = 0.0:
	set(value):
		delay_in_seconds = str(value)
		update_configuration_warnings()
	get:
		if delay_in_seconds.is_valid_float():
			return float(delay_in_seconds)
		return 0.0

## An expression for the delay in seconds before the transition is taken.
## This expression can use all expression properties of the state chart.
## If the expression does not evaluate to a valid float or a negative value, 
## the delay will be 0. When the delay is 0, the transition will be taken immediately.
## The transition will only be taken if the state is still active when the delay has 
## passed and has never been left. 
var delay_in_seconds:String = \"0.0\":
	set(value):
		delay_in_seconds = value
		update_configuration_warnings()


## Read-only property that returns true if the transition has an event specified.
## @deprecated: this property is no longer needed. It will be removed in a future version. 
var has_event:bool:
	get:
		return event != null and event.length() > 0


## Returns true if this transition is potentially triggered by the given trigger type.
func is_triggered_by(trigger_type:StateChart.TriggerType) -> bool:
	if _dirty:
		_refresh_caches()
	return (_supported_trigger_types & trigger_type) != 0

## Takes this transition immediately or with a delay if defined
## Note: if there is a delay on this transition and immediately param is true, it forces the transition to be taken without the delay
func take(immediately:bool = true) -> void:
	var parent_state:StateChartState = get_parent() as StateChartState
	if parent_state == null:
		push_error(\"Transitions must be children of states.\")
		return

	if parent_state._chart._frozen:
		push_error(\"The state chart is currently frozen, so transition '\" + name + \"' cannot be taken.\")
		return
	
	parent_state._run_transition(self, immediately)

## Evaluates the guard expression and returns true if the transition should be taken.
## If no guard expression is specified, this function will always return true.
func evaluate_guard() -> bool:
	if guard == null: 
		return true

	var parent_state:StateChartState = get_parent() as StateChartState
	if parent_state == null:
		push_error(\"Transitions must be children of states.\")
		return false
		
	return guard.is_satisfied(self, get_parent())


## Evaluates the delay of this transition.
func evaluate_delay() -> float:
	# if the expression just is a single float, skip the evaluation and just 
	# return the float value. This is a performance optimization.
	if delay_in_seconds.is_valid_float():
		return float(delay_in_seconds)
	
	# evaluate the expression
	var parent_state:StateChartState = get_parent() as StateChartState
	if parent_state == null:
		push_error(\"Transitions must be children of states.\")
		return 0.0

	var result = ExpressionUtil.evaluate_expression(\"delay of \" + DebugUtil.path_of(self), parent_state._chart, delay_in_seconds, 0.0)	
	if typeof(result) != TYPE_FLOAT:
		push_error(\"Expression: \", delay_in_seconds ,\" result: \", result,  \" is not a float. Returning 0.0.\")
		return 0.0

	return result

## Resolves the target state and returns it. If the target state is not found,
## this function will return null.
func resolve_target() -> StateChartState:
	if _dirty:
		_refresh_caches()
	return _target

func _get_configuration_warnings() -> PackedStringArray:
	var warnings:Array = []
	if get_child_count() > 0:
		warnings.append(\"Transitions should not have children\")

	if to == null or to.is_empty():
		warnings.append(\"The target state is not set\")
	elif resolve_target() == null:
		warnings.append(\"The target state \" + str(to) + \" could not be found\")

	if not (get_parent() is StateChartState):
		warnings.append(\"Transitions must be children of states.\")
		
	if delay_in_seconds.strip_edges().is_empty():
		warnings.append(\"Delay must be a valid expression. Use 0.0 if you want no delay.\")
	
	return warnings

func _get_property_list() -> Array:
	var properties:Array = []
	properties.append({
		\"name\": \"delay_in_seconds\",
		\"type\": TYPE_STRING,
		\"usage\": PROPERTY_USAGE_DEFAULT,
		\"hint\": PROPERTY_HINT_EXPRESSION
	})
	
	# hide the old delay_seconds property
	properties.append({
		\"name\": \"delay_seconds\",
		\"type\": TYPE_FLOAT,
		\"usage\": PROPERTY_USAGE_NONE
	})

	return properties

	
func _refresh_caches():
	_dirty = false
	var is_automatic:bool = (event == null or event.length() == 0)
	
	if to != null and not to.is_empty():
		var result:Node = get_node_or_null(to)
		if result is StateChartState:
			_target = result
			
	_supported_trigger_types = 0
	if not is_automatic:
		# non-automatic transitions can only be triggered by events
		_supported_trigger_types |= StateChart.TriggerType.EVENT
	else:
		# automatic transitions can be triggered by multiple conditions.
		# ALL automatic transitions can be triggered by state enter
		_supported_trigger_types |= StateChart.TriggerType.STATE_ENTER
		# ALL automatic transitions remain \"in play\" until the state is left. While
		# \"in play\" they can be triggered by property changes or state changes.
		# Which changes exactly are supported is determined by the used guard(s).
		
		# Check the guard for trigger types
		if guard != null:
			_supported_trigger_types |= guard.get_supported_trigger_types()



	
	
"

[sub_resource type="GDScript" id="GDScript_3qlw1"]
script/source = "@tool
@icon(\"animation_tree_state.svg\")
class_name AnimationTreeState
extends AtomicState


## Animation tree that this state will use.
@export_node_path(\"AnimationTree\") var animation_tree:NodePath:
	set(value):
		animation_tree = value
		update_configuration_warnings()

## The name of the state that should be activated in the animation tree
## when this state is entered. If this is empty, the name of this state
## will be used.
@export var state_name:StringName = \"\"


var _animation_tree_state_machine:AnimationNodeStateMachinePlayback

func _ready():
	if Engine.is_editor_hint():
		return
		
	super._ready()
	
	_animation_tree_state_machine = null
	var the_tree = get_node_or_null(animation_tree)

	if is_instance_valid(the_tree):
		var state_machine = the_tree.get(\"parameters/playback\") 
		if state_machine is AnimationNodeStateMachinePlayback:
			_animation_tree_state_machine = state_machine
		else:
			push_error(\"The animation tree does not have a state machine as root node. This node will not work.\")
	else:
		push_error(\"The animation tree is invalid. This node will not work.\")


func _state_enter(transition_target:StateChartState):
	super._state_enter(transition_target)

	if not is_instance_valid(_animation_tree_state_machine):
		return

	var target_state = state_name
	if target_state == \"\":
		target_state = get_name()

	# mirror this state to the animation tree
	_animation_tree_state_machine.travel(target_state)


func _get_configuration_warnings():
	var warnings = super._get_configuration_warnings()
	warnings.append(\"This node is deprecated and will be removed in a future version.\")

	if animation_tree.is_empty():
		warnings.append(\"No animation tree is set.\")
	elif get_node_or_null(animation_tree) == null:
		warnings.append(\"The animation tree path is invalid.\")

	return warnings
"

[node name="Character" type="CharacterBody2D"]
collision_layer = 2
collision_mask = 5
script = ExtResource("1_5bw4n")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("1_1dj28")
hframes = 11

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(1, 2)
shape = SubResource("CapsuleShape2D_5bw4n")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
active = false
libraries = {
&"": ExtResource("3_4xhno")
}

[node name="AnimationTree" type="AnimationTree" parent="."]
tree_root = SubResource("AnimationNodeStateMachine_4xhno")
anim_player = NodePath("../AnimationPlayer")
parameters/Move/blend_position = 2.024

[node name="StateChart" type="Node" parent="."]
script = SubResource("GDScript_4xhno")
metadata/_custom_type_script = "uid://couw105c3bde4"

[node name="Root" type="Node" parent="StateChart"]
script = SubResource("GDScript_tvgm1")
metadata/_custom_type_script = "uid://c1vp0ojjvaby1"

[node name="Movement" type="Node" parent="StateChart/Root"]
script = SubResource("GDScript_trqsh")
initial_state = NodePath("Grounded")
metadata/_custom_type_script = "uid://jk2jm1g6q853"

[node name="Grounded" type="Node" parent="StateChart/Root/Movement"]
script = SubResource("GDScript_8y6tv")
metadata/_custom_type_script = "uid://cytafq8i1y8qm"

[node name="To Jump" type="Node" parent="StateChart/Root/Movement/Grounded"]
script = SubResource("GDScript_022ct")
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="To Airborne" type="Node" parent="StateChart/Root/Movement/Grounded"]
script = SubResource("GDScript_022ct")
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="Airborne" type="Node" parent="StateChart/Root/Movement"]
script = SubResource("GDScript_trqsh")
initial_state = NodePath("HistoryState")
metadata/_custom_type_script = "uid://jk2jm1g6q853"

[node name="To Grounded" type="Node" parent="StateChart/Root/Movement/Airborne"]
script = SubResource("GDScript_022ct")
to = NodePath("../../Grounded")
event = &"grounded"
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="Walled" type="Node" parent="StateChart/Root/Movement"]
script = SubResource("GDScript_3qlw1")
metadata/_custom_type_script = "uid://488xerv8d0xh"

[node name="To Jump" type="Node" parent="StateChart/Root/Movement/Walled"]
script = SubResource("GDScript_022ct")
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="To Grounded" type="Node" parent="StateChart/Root/Movement/Walled"]
script = SubResource("GDScript_022ct")
to = NodePath("../../Grounded")
event = &"grounded"
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="AnimationControl" type="Node" parent="StateChart/Root"]
script = SubResource("GDScript_trqsh")
initial_state = NodePath("Idle")
metadata/_custom_type_script = "uid://jk2jm1g6q853"

[node name="Idle" type="Node" parent="StateChart/Root/AnimationControl"]
script = SubResource("GDScript_3qlw1")
metadata/_custom_type_script = "uid://488xerv8d0xh"

[node name="To Moving" type="Node" parent="StateChart/Root/AnimationControl/Idle"]
script = SubResource("GDScript_022ct")
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"

[node name="Move" type="Node" parent="StateChart/Root/AnimationControl"]
script = SubResource("GDScript_3qlw1")
metadata/_custom_type_script = "uid://488xerv8d0xh"

[node name="To Idle" type="Node" parent="StateChart/Root/AnimationControl/Move"]
script = SubResource("GDScript_022ct")
delay_in_seconds = "0.0"
metadata/_custom_type_script = "uid://cf1nsco3w0mf6"
